# -*- org -*-
#+TITLE: Guide to Haskell for the Absolute Beginner
#+COLUMNS: %8TODO %10WHO %3PRIORITY %3HOURS(HRS) %80ITEM
#+OPTIONS: author:nil creator:t H:9
#+HTML_HEAD: <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans">
#+HTML_HEAD: <link rel="stylesheet" href="/org-mode.css" type="text/css"/>
# #+HTML_HEAD: <link rel="stylesheet" href="/styles/toc.css" type="text/css">
# #+HTML_HEAD: <script src="/scripts/jquery-3.3.1.js" type="text/javascript"></script>
# #+HTML_HEAD: <script src="/scripts/toc-manipulation.js" type="text/javascript"></script>
#+BEGIN_EXPORT html
<script type="text/javascript">
  PAGE_URL = "http://tarheel-nc.s3-website-us-east-1.amazonaws.com/Haskell/beginners-guide-to-haskell.html";
  PAGE_IDENTIFIER = "tarheel-nc/haskell-beginners-guide";
</script>
#+END_EXPORT

* Overview

  So, I got a wild hair and wondered what an introduction to Haskell would look like to someone who
  doesn't really computer at all, except to use a laptop or smartphone to surf the web and write
  emails and social media posts.

  Let's go. :)  (Hmm, maybe I should find some emojis for this static web site thingie.)

* Basic Basics

  Wait, before I head into syntax, I should back up a few steps.

  Computers are programmable machines, meaning, they take in input, examine the input, /make
  decisions/[fn:1], and then produce outputs.  Sometimes the inputs come from other hardware (like
  an airspeed sensor, say), and the outputs go to more hardware (like a wing flap actuator, say).

  But, also, sometimes the input comes from a human and the output goes back to a human (maybe even
  the same human).

  The process of making the same machine respond to different inputs in different ways might be
  referred to as "programming".  (Unless you're a hardware person and you just design the machine to
  act different in different circumstances [like, say, when the power switch is on, it makes noise,
  but when the power switch is off, it doesn't], but we don't care about that right now.)

[fn:1] This blew me away when I was a wee nerd in the eighth grade, and it's probably why I got into
computers in the first place ("computers making decisions!!!"), but it's not like humans make
decisions.  We anthropomorphize too much.  Outcome of a machine "making decisions" is simply a fork
in the program based on inputs.  Or a differentiating circuit or something.  It's not like the
machine /considers/ its choices and comes to a reasoned decision, taking all factors into account.
Even so, these sorts of things can Make Life Better(tm), so that's another reason I'm into it.

* How a program makes a computer do stuff, at the level of electronics and stuff

  So, a computer's hardware does input and output as a bunch of tiny voltage changes (just "high"
  and "low" -- we don't even care about the difference between 2.2 volts and 2.3 volts, unless one
  is "low" and the other is "high") on a bunch of wires.  Those wires get hooked up to more
  electronics and hardware like the switches under keyboard keys and electrical motors and stuff,
  but we don't care about that.  We just care about the tiny incoming and outgoing voltages.

  So, the computer has instructions like:

  - Take the current set of (8, say) input voltages and save them on a bunch of other internal
    electronic circuits called "flip-flops" (because, as long as the circuit has power, the amount
    of current running through a flip-flop is steady, until another voltage is applied to a part of
    the circuit, and then the flip-flop changes state, and has, say, NO (or very little) current
    running through it.  So it flip-flops).
    - We design these flip-flops to be super-responsive and fast (which also makes them expensive),
      and we call them "registers" because they register (save) data.  Like a cash register, which
      is all mechanical:  you push a key and a flag pops up and stays up, until you push another key
      to lower the flag.

  SO ANYWAY...

  - Take the current set of 8 input voltages and save them on this register.  Maybe we call the
    register "A" for no good reason apart from the fact that it's the first letter of the alphabet,
    but also... "accumulator" starts with "a", huh.
    - By the way, each of these eight tiny voltages (high or low) is called a "bit", which is a
      shortening of "binary digit" because (a) who wants to say all that all the time, and (b)
      really, it's just a bit of data, right?
      - Also, eight bits is a byte, because who wants to say "eight bits" all the time, when "byte"
        will do?  Plus, it scares the uninitiated.
        - Oh, wait, there's [[#binary-math][MATH]].  You can go read that now and then come back here, because it's
          about to get important.
  - Take this other set of 8 voltages sitting out in circuits in memory (which is slower and cheaper
    than registers) and store it another register.  Maybe we call that register "B".  (Incidentally,
    "base" starts with a "b".)
  - Subtract B from A (remember the [[#binary-math][MATH]]?), being sure to set flags indicating that we had to do a
    carry from some imaginary 9th bit.
  - If we had to carry (i.e., B was bigger than A), skip the next step.
  - Go to the end of the program (remember, we might be skipping this step).
  - Send some output voltages that turns on a light.
  - THE END.  Ta-da!!!

  Except in "real life", it looks more like this:

  #+BEGIN_EXAMPLE
            INP   A
            LOAD  B 1000
            CMP   B
            JC    END
            LOAD  C 1001
            OUTP  C
    END:
  #+END_EXAMPLE

  And, man, is /that/ ugly.  Who wants to do that?  (Well, maybe people who write code for fighter
  jets and washing machines because it has to be as small and fast and tight and cheap as possible,
  but apart from /those/ guys....)

  That's why we have /compilers/.

* Compilers

  So, we want to write our instructions to the computer in something besides gibberish.  The stuff
  above is called "machine language" or "assembler language" (there's a difference, but we can take
  them to be the same for now).  It's low-level, at the level the /machine/ "understands"[fn:2].  We
  want a higher-level language.  There are lots of them, for various types of problems:

  - BASIC :: For beginners.  A BASIC program to match the above program might look like this:
             #+BEGIN_EXAMPLE
               A = INPUT 1
               B = 152
               IF A < B THEN OUTPUT 2
             #+END_EXAMPLE 
  - FORTRAN :: For science-y number-y type stuff.
  - COBOL :: For business stuff like accounts receivable and payroll ledgers.
  - LISP :: For people who think everything is a list and computers can be made to appear
            intelligent if they can just process all the lists of stuff we have in our heads.
  - Pascal :: For people who are tired of immense blobs of BASIC code.
  - C :: For people who want to get code working on completely new hardware with a minimum of
         screwing around with interpreters (like for BASIC) or compilers (for Pascal).  And who also
         hate Pascal's constant stream of compiler errors when they try to do stuff like subtract a
         decimal number from an integer.
  - C++ :: For people who are tired of immense blobs of C code that constantly break when you make
           one tiny change.
  - Java :: For people who are tired of all the memory-management errors in C++ programs.
  - C# :: This is pretty similar to Java, but it's for people who love Microsoft so much that they
          can't see anything not invented by Microsoft.  Or whose bosses tell them "we're going with
          Microsoft because that way, people won't have to know so much to produce results.  Also,
          it's pretty."
  - Haskell :: For people who are tired of dealing with errors caused by subroutines that have
               undocumented side effects, and are also ready to work at a higher level than just
               slinging data around (they want to try slinging /functions/).

  We call the programs that translate programs written in the above high-level languages into
  machine language /compilers/, because they /compile/ the code.  Admiral Grace Hopper gets credited
  with that word, because she had a bunch of subroutines floating around she was constantly
  compiling into whatever new code she wrote, to be loaded onto the machines she was working with.

[fn:2] Oh, look, more anthropomorphization.

* MATH
  :PROPERTIES:
  :CUSTOM_ID: binary-math
  :END:

  So, uh, collections of 8-bit bytes can be interpreted as numbers and slung around that way.  Get
  ready for some base-2 (binary) math.

  We interpret a high voltage as a 1 (like, the number 1) and a low voltage as a 0.  If we string 8
  of them together in order, we get what looks like a number:

  : 10101100

  And, like decimal numbers (ones place, tens place, hundreds place, ...) the order of the digits is
  important.  And, like decimal, where the ones place is how many ones do you have (and one is just
  10^0, because anything raised to the 0-th power is just 1 (except 0, maybe, what is 0^0? I
  dunno)), and the tens place is how many tens do you have (and ten is just 10^1) and the hundreds
  place is how many hundreds to you have (and a hundred is just 10^2) and so on, binary is the same
  way, except we use 2 as the base instead of 10.

  So, the question is: how many ones do you have (where one is just 2^0) and how many twos do you
  have (where two is 2^1) and how many fours do you have (where four is 2^2) and how many eights do
  you have (where eight is 2^3) and how many sixteens do you have, and so on.

  And you can see that every digit can only be 0 or 1, because if it was 2, it would just carry
  over to the next place, right?  So, like, if we had two ones, that's really just one two (stick
  with me), and if we had two twos, that's really just one four, and so on, right?

  So, the number above is (and, of course, we have to go backwards, because how else are you going
  to learn to ride a unicycle?)...

  # Oh, cool, I can do math!
   
  #+BEGIN_CENTER
  $0 \times 2^0 + 0 \times 2^1 + 1 \times 2^2 + 1 \times 2^3 + 0 \times 2^4 + 1 \times 2^5 + 0
  \times 2^6 + 1 \times 2^7 = 172$
  #+END_CENTER

  #+BEGIN_QUOTE 
  a.k.a. (in case your browser doesn't display [[https://en.wikipedia.org/wiki/MathJax][MathJax]]):

  #+BEGIN_CENTER
  0 ✕ 2^0 + 0 ✕ 2^1 + 1 ✕ 2^2 + 1 ✕ 2^3 + 0 ✕ 2^4 + 1 ✕ 2^5 + 0 ✕ 2^6 + 1 ✕ 2^7 = 172
  #+END_CENTER
  #+END_QUOTE 

  172!

  Most of the time, we don't care, except when we do.  Now you can go back to reading wherever you
  were before.

* Turing vs. Church and Why Haskell?

  I have to talk about this for a moment, because it kind of helps address the "Why Haskell?"
  question. 

** Turing
   
   Everybody's heard of Alan Turing (right?).  Father of modern computing or some such.  He was a
   mathematician in the olden days before electronics, so all his thoughts of computers were in his
   head.  There are a couple of things that make him a big deal:

*** Turing machines

    Turing imagined a machine that had an infinitely-long tape and a finite set of basic
    instructions like "read whatever's on the tape at the current position", "move the tape forward
    or backward one position", "write some piece of data from a register onto the tape", "subtract
    two numbers in memory", "if there was a carry, skip the next instruction", etc.  (This is from
    memory, so if I got it wrong, sue me.)

*** Computability

    Well, strictly speaking, this wasn't Turing.  This was a bunch of other people, but the idea was (is)
    that all computers can be shown to be equivalent to a Turing machine, so if a problem can be
    shown to be solvable on a Turing machine, any modern computer can solve it.  (No statements are
    made about how /long/ a solution might take, and this leads to more interestingness that I'm not
    going into now.)

** Church

   So, while everybody's going on and on about Alan Turing, there's this other guy, named Alonzo
   Church, who was roughly contemporary with Turing.  He came up with a form of math called "lambda
   calculus".  It's all functions.

   So, while Turing is inventing a machine that stores state on a tape (with assignment statements,
   basically) and computes that way, Church is inventing a form of math that "stores" state in
   mathematical function results.

*** Church-Turing Thesis

    The electrifying thing is the idea that lambda calculus can do everything a Turing machine can
    and vice versa.  (This hasn't been proven, but everybody pretty much accepts it as true, so I
    do, too.)

** Why Haskell?
   
    So: computing without assignment statements.  What's an assignment statement? you ask.

    Remember that BASIC code above?

    #+BEGIN_EXAMPLE
      B = 152
    #+END_EXAMPLE

    That's an assignment statement.  We're /assigning/ the value 152 to whatever area of memory =B=
    represents.  This is like a Turing machine scribbling on its tape.

    That's all fine and dandy, but what if you modified the above program to call a subroutine
    between the time you assigned the value 152 to =B= and the time you used =B=, and /said
    subroutine modified =B= without telling you it would?/

    #+BEGIN_EXAMPLE
      A = INPUT 1
      B = 152
      REMark The following function modifies B but the documentation doesn't say anything about that,
      REMark nor can we read the code because we bought it from another company
      CALL SPIFYRTN
      IF A < B THEN OUTPUT 2
    #+END_EXAMPLE

    So now, we loaded 152 into =B=, and we happen to know the input to the program was 12 (because
    we measured it with a voltmeter), so the =OUTPUT 2= statement /should/ have turned on the
    light, but it didn't!  What's wrong?

    After screwing around for a day, we finally think to check =B= at the time of the =IF=
    statement, and we find that, lo and behold, it's /not/ 152 as we thought, but 0!  Because the
    =SPIFYRTN= call changed it behind our backs!  (With its own not-easily-visible assignment
    statement.  Not a very spiffy routine at all.)  Good thing we found this in testing, because if
    we had shipped this code, that light not lighting up is the "patient is having a heart attack"
    light, and we could have killed someone.

    This is a big deal, because assignment statements lead to an enormous class of bugs (basically,
    undocumented subroutine side effects).  So, imagine how great it would be if we could write
    programs without assignment statements, and not even have these sorts of bugs.  That's Haskell
    (and a bunch of other functional languages like OCAML and F# and Scala, but Haskell is kind of
    the granddaddy).

*** A tiny bit about Haskell

    Haskell the language was named after yet another old-timey math guy (a logician, actually) whose
    name was Haskell Curry.  I don't know what he's famous for.

    The primary (the Swedes would probably say "hold on there, hoss, you mean /a/ primary") place
    where Haskell research and language compiler development takes place is the University of
    Glasgow, in Scotland.  The Haskell compiler we'll be using is the Glasgow Haskell Compiler, and
    the main command to run the compiler is =ghc=.  (The people in Glasgow call it the Glorious
    Haskell Compiler, though.)

    It's possible to run an /interpreter/ (kind of an instant-feedback compiler), and that command
    is =ghci=.

    You can get started with the entire shebang at https://haskell.org.  Download and install the
    "Haskell Platform" and you'll be off to the races.

* DONE What is Haskell?
  CLOSED: [2019-02-18 Mon 22:02]

  - CLOSING NOTE [2019-02-18 Mon 22:02]

  So, what is there about Haskell to appeal to the geek?

  Haskell is a lazy, statically-typed, pure functional programming language.

  Breakdown:

** Lazy

   Haskell doesn't do any computations until it really needs to.  You can set up the most
   monstrously-complex computation and Haskell will only evaluate it when it really needs to, /even
   if it looks like it should evaluate/.  Seriously, Haskell only waits until it /REALLY/ needs to
   do the computation.

   Suppose I define a function that looks like this:

   : f x y = if (x < 0) then y else x

   Meaning, the function gives the value y if x is negative, otherwise it just gives the value
   of x.

   Then, suppose I define some other horribly complex and expensive function /h/ and call /f/ like
   this:

   : f 2 (h 12)

   Meaning (you might think), "calculate the value of $h(12)$ (let's call the result $z$, for no
   good reason), even though it's horribly complex, and then call $f(2, z)$.  Since the first
   argument is 2, we get the 2 back, so... why did we pay the cost of computing $h(12)$?

   Haskell doesn't do that.  It's lazy.  It puts off the calculation until it really needs it.

   Here's a cool example:

   #+BEGIN_EXAMPLE
     Prelude> :{
     Prelude| let g :: Int -> [a] -> Int
     Prelude|     g x ys = if (x < 0) then (length ys) else x
     Prelude| :}
     Prelude> g 2 [1..10]
     2
     Prelude> g (-2) [1..10]
     10
   #+END_EXAMPLE

   Spiffy, right?  If /x/ is negative, it returns the length of the list /ys/, otherwise it just
   returns /x/.

   What if we hand it an infinite list (you can do that; see [[#infinite-lists][Infinite lists]]).  Now we're expecting
   it to count the length of an infinite list.  That's like that Star Trek episode where Spock asks
   the Evil Computer to compute the last digit of pi.  It ain't never gonna come back.

   Except... if we hand the function a positive first argument, it doesn't even /need/ to count the
   length of the list, and it doesn't.

   #+BEGIN_EXAMPLE
     Prelude> g 2 [1..]
     2
   #+END_EXAMPLE

   Boom.

   Just for grins, let's see what happens when I use a negative number:

   #+BEGIN_EXAMPLE
     Prelude> g (-2) [1..]
     ^CInterrupted.
   #+END_EXAMPLE

   (I got impatient after, like, 7 seconds, because I knew it wasn't coming back.)

** Statically-typed

   Haskell knows the types of everything before the program starts running.  And you can't hand
   something of the wrong type off to something that expects it to be right type.

   This is different from languages that are dynamically typed.  If I declare a numeric function and
   hand it a string like "2", we expect the function to Do The Right Thing and convert the "2" to 2
   and go from there.  If we hand said function a string like "onyx", it'll try to convert "onyx" to
   a number and almost certainly bomb out, at run time.  (Or, worse, decide "onyx" is really 0, and
   sail merrily on, giving what looks like a correct calculation.  What if I gave it "5even"?  Too
   bad, eh?)

*** Type inference
    
   Along with the static typing comes something called "type inference", which means you can be sort
   of casual about your declarations and Haskell will do a pretty good job of figuring out what you
   really need.

   For example, suppose we define said numeric function like this:

   #+BEGIN_EXAMPLE
     Prelude> f x = x^2
     Prelude> f 9
     81
   #+END_EXAMPLE

   (So, /f/ squares numbers.)
   
   And then we ask Haskell what the type of f is:

   #+BEGIN_EXAMPLE
     Prelude> :t f
     f :: Num a => a -> a
   #+END_EXAMPLE

   What Haskell is saying here is that /f/ is a function that takes some type /a/ and returns the
   same type, so long as /a/ is a number (=Num=) of some sort.  So, integer, floating point, Roman
   numeral (so long as you define the math on that puppy), tally marks, whatever.

   How did it figure out that /a/ needs to be a number?  We used the exponentiation operator (=^=),
   which is a mathematical operator.  (Maybe I should have used =+= here to make things simpler.)

** Pure

   Here's where things start to get really interesting.  "Pure" means Haskell has no assignment
   statements.  It has no exceptions that say "well, in this /special case/, you can assign a value
   to a variable."

*** Memoizing

   That puritanical stance against assignment statements has some nice outcomes.  For one, whenever
   you call a function, since there are no side effects, you can rely on that function returning the
   same results for the same arguments.  In fact, that allows Haskell to simply /cache/ the result,
   so, for an expensive function, the first time you call it (and really need it), you pay the
   price, but from then on, for the same arguments, Haskell just returns the value it memorized.
   So, you get a nice performance bump.

   There's an actual verb for that, and it's not "memorize".  Instead, we say /memoize/, like that
   bishop in /Princess Bride/.

*** Parallelizing

    (That was awkward, but I wanted to match "Memoizing".)  If there aren't side effects to
    functions (like a function trying to scribble on a global variable), then you can break work up
    into chunks and do the chunks in parallel.  Say, you have a list of a million words and four
    CPUs and you want to sort the list.  You break it up into four chunks and hand the job of
    sorting each chunk off to each processor and then merge the results when they're done.

    That's a little bit of a dumb example, but the point is: if a function has side effects, you
    can't easily parallelize it, because then the same side effect would happen multiple times, and
    that would probably be Bad.

** Functional

   And, finally, Haskell does everything with functions, slinging them around pretty much with gay
   abandon, as in:  "here's a function, I don't know what it is (except it's mathematical); call it
   on each number in this list, please".  Or: "here are two functions, I don't know what they are
   (except they're mathematical), please compose them together and call the composition on this list
   of numbers".

   (You probably remember /function composition/ from your math days: $f(g(x)) = (f \circ g)(x)$.
   That "$\circ$" is the composition operator you know and love.)

* SUPER Basic Syntax
  :PROPERTIES:
  :CUSTOM_ID: basic-syntax
  :END:

  Ok.  So, now that we've established all that, and you've read down to here, I'll assume you're
  ready and interested to learn some Haskell.

  Haskell code looks pretty simple, at first.  If you fire up =ghci= and type an expression, it'll
  evaluate the expression and tell you the result.

  So, if you type =2=, you get =2=.  And if you type ="Hello!"=, you get ="Hello!"=.  You can also
  type expressions, like =2 + 3= and =2 * 3=, which is addition and multiplication.

  Like this:

  #+BEGIN_EXAMPLE
    deimos$ ghci
    GHCi, version 8.4.3: http://www.haskell.org/ghc/  :? for help
    Loaded GHCi configuration from /Users/john/.ghci
    Prelude> 2
    2
    Prelude> "Hello!"
    "Hello!"
    Prelude> 2+3
    5
    Prelude> 2 * 3
    6
    Prelude> :q
    Leaving GHCi.
  #+END_EXAMPLE

  (Deimos is the name of my computer (a Mac).  This is all happening at a command prompt (no mouse clicking
  for you!), which Windows users sometimes refer to as "the black window".  You can get to it by
  holding down the Windows key and hitting "R" and then typing "cmd" in the little text input field
  and hitting the "Enter" key.  /Surely/ you have done something like this before.  You can also use
  the Start menu to open a Console window, it's the same thing.)

** Functions (Simplest)

  And you can define functions.  Haskell functions look different from math functions.  Math
  functions look like this:

  #+BEGIN_CENTER
  $c(x) = (x - 32) / 1.8$
  #+END_CENTER

  #+BEGIN_QUOTE
  Or, for those w/out MathJax:
  #+BEGIN_CENTER
  c(x) = (x - 32) / 1.8
  #+END_CENTER
  #+END_QUOTE
  
  That function converts Fahrenheit to centigrade, if you're interested.  The inverse function
  being:

  #+BEGIN_CENTER
  $f(x) = x * 1.8 + 32$
  #+END_CENTER
  
  Haskell functions don't have the parentheses.  They just use spaces.  In fact, when you see two
  things separated by spaces in Haskell (that aren't explainable by normal syntax rules), it's
  almost always a function being applied to an argument.

  So, if we were to apply the function =c= to the value 22 (°F), it would look like this:

  #+BEGIN_EXAMPLE
    Prelude> c 22
    -5.555555555555555
  #+END_EXAMPLE

  So, like, -6 °C.  No parentheses.  You could use them, but they'd be useless.  Parentheses are
  used like in regular math, to prioritize math operations that would normally be low priorities, as in
  the definition of the function =c= above.

  Defining that function in Haskell looks kind of the same:

  #+BEGIN_EXAMPLE
    Prelude> c x = (x-32)/1.8
  #+END_EXAMPLE
  
  (Try it!  I know you already installed Haskell, didn't you?)

  And you can convert centigrade back to Fahrenheit, so when Midnight Oil sings "boiling diesels
  steam in 45°" (https://youtu.be/jpkGvk1rQBI), you can know how hot that is.

  #+BEGIN_EXAMPLE
    Prelude> f x = x * 1.8 + 32
    Prelude> f 45
    113.0
  #+END_EXAMPLE
  
  Ok, that's it.  That all.  Now you can use Haskell to balance your checkbook.  Just fire up =ghci=
  and start entering some mathematical expressions.

  #+BEGIN_EXAMPLE
    Prelude> 1800-750
    1050
    Prelude> 1050-850
    200
    Prelude> 200-30
    170
    Prelude> 170-250
    -80
    Prelude> -80-350
    -430
  #+END_EXAMPLE
  
  :(

  I'm guessing you didn't need Haskell for that, though.

** Special note on using ()s around negative numbers
   
  By the way, while we're on the topic of negative numbers, it's best to surround them with parentheses, e.g.

  : (-80) - 350

  We got away with no parens in the example above, in more-complicated situations, you'll see weird errors:

  #+BEGIN_EXAMPLE
    Prelude> 2 * -3

    <interactive>:1:1: error:
        Precedence parsing error
            cannot mix `*' [infixl 7] and prefix `-' [infixl 6] in the same infix expression

    Prelude> 2 * (-3)
    -6
  #+END_EXAMPLE 

* DONE "Strings"
  CLOSED: [2019-02-18 Mon 17:39]

  - CLOSING NOTE [2019-02-18 Mon 17:39]

  It occurs to me that I casually sling around the word "string" without defining it.  It's probably one of the first
  true technical buzzwords you can learn: it just means a string of characters.  That's all.

  So, you have characters like 'h', and 'e', and 'l', and 'o'.  Typically, /characters/ (single letters or glyphs from
  whatever alphabet you're using) are indicated with single quotes (and Haskell and most of the other programming
  languages I mentioned above /require/ the use of single quotes for characters).

  And then you have /strings/, like ="hello"=.  And those are typically indicated with double quotes (and you're
  required to use double quotes by those same languages).

  As a funky technical note, ="a"= is a /string/ (containing only one character) and ='a'= is a /character/, and it's
  not the same as ="a"=.

  There's a technique for getting special characters into strings, but hopefully I'll remember to mention it later,
  when I need to.

* DONE Lists
  CLOSED: [2019-02-18 Mon 20:23]

  - CLOSING NOTE [2019-02-18 Mon 20:23]

  I mentioned two types in the initial intro in [[#basic-syntax][Basic Syntax]] (implicitly): numbers and strings.  We
  define these things functionally, really.  Numbers are things you can do math with, and strings
  are things you can read and display.  (For example, =putStr= is a function that puts a string
  (and only a string) to the output.)

  There's another common, basic type of data: lists.  Lists are collections of data that are all of
  the same type, and come in some sort of order (first, next, etc., etc., last).

  So, =[1, 2, 3]= is a list.  So is =[2, 3, 1]=, and it's different from the first list because the
  ordering is different.

  A string is just a list of characters, so ="hello"= is just the same as =['h', 'e', 'l', 'l',
  'o']=.

** Lists specified algorithmically (ranges)

   You can list out the contents of a list as above, but you can also specify the contents of the
   lists a different way.  Essentially, you use a recipe.

   =[1..10]= is a list of all the integers from 1 to 10.

   =[2,4..10]= is a list of all the even numbers from 2 to 10.

   Sadly, you can only go by addition (or subtraction), so you can't, for instance, expect
   =[1,2..128]= to be a list of all the powers of 2 from 1 to 128.  Nor can you give Haskell a hint
   with something like [1,2,4..128].

   /However/, there are more tricks!

   =[ 2^x | x <- [1..10]]= is the aforementioned "powers of two" list.  If you go back to your math
   days, you can almost read this as:

   "THE LIST OF (=[=) all 2^x SUCH THAT (=|=) x IS TAKEN FROM (=<-=) the list of integers from 1 to
   10"

   You can make the condition more complicated:

   =[ 2^x | x <- [1..10] , 2^x <= 128]= is the same list as above, except we also require 2^x to be
   les than or equal to 128.

** DONE Infinite lists
   CLOSED: [2019-02-18 Mon 22:03]
   :PROPERTIES:
   :CUSTOM_ID: infinite-lists
   :END:

   - CLOSING NOTE [2019-02-18 Mon 22:03]

   You can do this. This blows more-experienced developers' minds, but you can probably be
   comfortable with this concept.

   =[1..]= is the infinite list of positive integers.  (I don't believe you can have a list be
   infinite on both ends, but there might be a trick you can pull if you really want something
   like that.  All lists have to have a starting point.)

   If you try to print that list out, you'll be waiting for a long time for the printing to stop.
   (You can hit ctrl-C (hold down the control key and hit the 'C' key) to stop it.)

   But you can do something like this:

   =take 10 [1..]= means "take the first ten items from the infinite list of integers".

   Which sounds pretty stupid, but it can come in handy sometimes when you have a less-predictable
   infinite list to deal with.

* DONE Layout rule
  CLOSED: [2019-02-18 Mon 17:29]

  - CLOSING NOTE [2019-02-18 Mon 17:29]
     
  This is tough to define (especially when you don't really understand it, which is true in my case), but here's how I
  think it goes:

  - Haskell statements are separated by semicolons.
  - Groups of haskell statements are surrounded by curly braces (={}=).

  BUT...

  If you put the things separated by semicolons on separate lines, you don't need the semicolons.

  And if you indent the things grouped by braces, you don't need the braces.

  So...

  #+BEGIN_SRC haskell
    module Layout where

    -- 'do' is one of those statements that expects curly braces containing a list of statements.  The only such statements
    -- (or keywords) are:
    --
    --      do
    --      where
    --      let
    --      of
    --
    -- And then, once you're in for a curly brace penny, you're in for semicolon pounds.  Meaning, every statement needs to
    -- be separated with semicolons.
    -- 
    oneLine = do { putStr "Hello, " ; putStrLn "there!" }

    -- But, you can put things on separate lines and indent them properly and get away w/out the braces and semicolons.
    laidOut = do putStr "Hello, "
                 putStrLn "there!"

    -- A more common alternative
    laidOut2 = do
      putStr "Hello, "
      putStrLn "there!"

    -- You can do this, too, if you want, but it will bollix everything up that comes after it.
    badLayout = do
    putStr "Hello, "
    putStrLn "there!"

    -- But once you commit to an indentation, you can't back out of it.  Everything else in that block needs to be indented
    -- the same.
    illegalLayout = do
            putStr "Hello, "
      putStrLn ", there!"

    -- Same problem here, because that first "putStr" is already "indented".
    illegalLayout2 = do putStr "Hello, "
    putStrLn "there!"
  #+END_SRC

* DONE Editors
  CLOSED: [2019-02-18 Mon 17:31]

  - CLOSING NOTE [2019-02-18 Mon 17:31]

  Speaking of the layout rule, you should get a smarter editor than Notepad, as spiffy as it is.

  For beginner types who haven't messed around with programming editors very much (and like "free" as a price), I
  recommend Visual Studio Code (https://code.visualstudio.com/).  Looks like most of the Haskell plugins are a bit
  complicated to install, but the simplest one seems to be the one named "Haskell Syntax Highlighting", so try that
  out.  Looks like it does some automatic indenting to kind of give you a hint as to when you need to indent more.

  (I have to put in a plug for my editor, [[https://www.gnu.org/software/emacs/][emacs]], but emacs is a journey of a lifetime.  I've been using it for coming
  up on 40 years now and I /still/ haven't figured out everything about it.)

* DONE Unit testing with Hspec
  CLOSED: [2019-02-19 Tue 11:41]

  - CLOSING NOTE [2019-02-19 Tue 11:41]

  Speaking of editors and getting set up, you should start early on unit testing.  "Unit testing" is testing little
  units of your work (as opposed to testing the entire program).  Unit testing is easier in pure functional languages
  because to test a function, you just call it.  You don't really need to "set stuff up" before you call it because
  there /is/ no state to be set up.  (Parameters for the functions might be complex, though, but it still feels easier
  than in "imperative" programming languages (which is what the rest of the world uses:  "do this, and save the result
  here; then do that, and save the result there; etc.").

  So, if you're writing a function you want to test, don't put code inside your main program to test it.  Your main
  program is not for testing, it's for accomplishing your overall goal, ya know?

  Instead, write a side program to do the testing.  So much easier then either (1) putting in and taking out code in
  your main program, or (2) firing up =ghci= and issuing the same manual tests over and over as you make little
  changes.  And you'll be running multiple tests because either you'll be writing multiple functions or you'll want to
  test multiple inputs to your function or both.

  Now that I've got you pumped up for unit testing, here's what it looks like.

  Say you're writing some program that works with Foos.  Put your Foo stuff (data types, functions) in a =Foo= module.
  Then, write a separate =FooSpec= module that looks like this:

  #+BEGIN_SRC haskell
    module FooSpec where

    import Test.Hspec
    import Foo -- Import the module containing the functions you wrote that you want to test.

    -- This is all black magic at this point.  Don't worry about it, just do the
    -- incantations.  The dollar signs are important, so pay attention to them.
    main :: IO ()
    main = hspec $ do
      describe "Some readable (English) phrase describing what you're testing in general" $ do
        it "Some phrase describing a specific single test you're performing, like '1 equals 1'" $
          -- Here you write some Boolean (true/false) expression that will be true
          -- when your test passes, and false otherwise
          1 == 1                    -- This test will succeed.
        it "Some other phrase for another test, like '1 equals 2'" $ do
          1 == 2                    -- This test will fail.
        it "Tigger tops are made of rubber" $ do
          getTopMaterial (Foo Tigger) == Rubber
        it "Tigger bottoms are made of springs" $ do
          getBottomMaterial (Foo Tigger) == Springs
  #+END_SRC

  (I added some silly stuff about tiggers, which, presumably, you defined in =Foo=.  If you actually want to run all
  this, comment out or delete the lines involving Foo and Tiggers, obviously.)

** Install =hspec=

   So, =hspec= doesn't come with the Haskell Platform, for some reason, so you'll need to use the =cabal= command
   (which /does/ come with Haskell Platform) to install it.  Issue the following command at the command prompt:

   : cabal install hspec

   It'll take a while and install a /bunch/ of stuff.

   When you compile the above code with ghc, you'll get some incomprehensible warnings about type defaults, but I'm
   guessing it's because I used actual integers rather than real code to be tested.  It's ok; it still runs fine.

** Run the test

   Fire up =ghci=, load the test module and run its main (or any other test functions (which probably have to have type
   =IO ()=)):

   #+BEGIN_EXAMPLE
     PS C:\Users\j6l\Documents\AmazonS3\Tarheel-NC\Haskell# ghci .\FooSpec.hs
     GHCi, version 8.6.3: http://www.haskell.org/ghc/  :? for help
     Loaded GHCi configuration from C:\Users\j6l\.ghci
     [1 of 1] Compiling FooSpec          ( FooSpec.hs, interpreted ) [flags changed]
     Ok, one module loaded.
     ,*FooSpec> main

     Some readable (English) phrase describing what you're testing in general
       Some phrase describing a specific single test you're performing
       Some other phrase for another test FAILED [1]

     Failures:

       FooSpec.hs:15:5:
       1) Some readable (English) phrase describing what you're testing in general Some other phrase for another test

       To rerun use: --match "/Some readable (English) phrase describing what you're testing in general/Some other phrase for another test/"

     Randomized with seed 1422829174

     Finished in 0.0181 seconds
     2 examples, 1 failure
     ,*** Exception: ExitFailure 1
   #+END_EXAMPLE

   You'll see green text for successful tests, and red text for failures (plus the word =FAILED=).

* DONE Hoogle
  CLOSED: [2019-02-19 Tue 11:56]

  - CLOSING NOTE [2019-02-19 Tue 11:56]

  [[https://www.haskell.org/hoogle/][Hoogle]] is the Haskell knowledge search engine, your entry point to the deep, dark, shark-infested waters that are the
  official Haskell library documentation.  This documentation is not written to be friendly, but it /is/ written to be
  comprehensive and correct.

  You could, for instance, look up "hspec".

* TODO Data type constructors, pattern-matching, and conditionals

  This sounds like an odd combination of topics, but bear with me.

** =Maybe=
** =Either=
** =deriving= and common classes
* TODO Currying (Function application is highest priority)

   =f 2 3 4= is =f 2= applied to =3=, yielding a curried function which is, in turn, applied to
   =4=.
    
* TODO Basic functions that show up a lot
** map
** filter
** take
** drop
** concat
* COMMENT Local spelling dictionary & whatnot

 #  LocalWords:  computability memoize
