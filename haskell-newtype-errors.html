<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-10-17 Wed 15:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes on Errors Encountered While Trying to Use Newtype to Declare a Type an Instance of Functor</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="org-mode.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Notes on Errors Encountered While Trying to Use Newtype to Declare a Type an Instance of Functor</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org81d7a34">1. Definition of Functor</a>
<ul>
<li><a href="#org6b6b27e">1.1. <code>Maybe</code> as a <code>Functor</code></a></li>
</ul>
</li>
<li><a href="#org405f334">2. Erroneous Definition of <code>Pair a b</code> as a Functor</a></li>
<li><a href="#org7cb7862">3. Errors</a></li>
</ul>
</div>
</div>

<div id="outline-container-org81d7a34" class="outline-2">
<h2 id="org81d7a34"><span class="section-number-2">1</span> Definition of Functor</h2>
<div class="outline-text-2" id="text-1">
<p>
According to <i>Learn You A Haskell</i>, <code>Functor</code> really only requires you define one function, <code>fmap</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Functor</span> f <span style="color: #a020f0;">where</span>
  fmap <span style="color: #8b6914;">::</span> (a <span style="color: #8b6914;">-&gt;</span> b) <span style="color: #8b6914;">-&gt;</span> f a <span style="color: #8b6914;">-&gt;</span> f b
</pre>
</div>

<p>
The "f" here is very confusing, and I wish people wouldn't do this, but it basically represents a
<i>type constructor</i> taking a single argument.  People use "f" to stand for "functor", which is a
typeclass, not a function.
</p>
</div>

<div id="outline-container-org6b6b27e" class="outline-3">
<h3 id="org6b6b27e"><span class="section-number-3">1.1</span> <code>Maybe</code> as a <code>Functor</code></h3>
<div class="outline-text-3" id="text-1-1">
<p>
This is pretty straightforward.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">data</span> <span style="color: #228b22;">MMaybe</span> a <span style="color: #8b6914;">=</span> <span style="color: #228b22;">NNothing</span> <span style="color: #8b6914;">|</span> <span style="color: #228b22;">JJust</span> a
  <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">Show</span>

<span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Functor</span> <span style="color: #228b22;">MMaybe</span> <span style="color: #a020f0;">where</span>
  fmap f (<span style="color: #228b22;">JJust</span> x) <span style="color: #8b6914;">=</span> <span style="color: #228b22;">JJust</span> (f x)
  fmap <span style="color: #a020f0;">_</span> <span style="color: #228b22;">NNothing</span> <span style="color: #8b6914;">=</span> <span style="color: #228b22;">NNothing</span>
</pre>
</div>

<p>
In <i>this</i> case, "f" represents just a regular old function <i>f</i> (the <code>(a -&gt; b)</code> part in the
definition above.  Note that this is plain old function definition, complete with
pattern-matching.
</p>

<p>
And, in <code>ghci</code>:
</p>

<pre class="example">
λ *Main&gt; fmap (*100) (JJust 2)
JJust 200

λ *Main&gt; fmap (*100) NNothing
NNothing
</pre>
</div>
</div>
</div>

<div id="outline-container-org405f334" class="outline-2">
<h2 id="org405f334"><span class="section-number-2">2</span> Erroneous Definition of <code>Pair a b</code> as a Functor</h2>
<div class="outline-text-2" id="text-2">
<p>
We define a "pair" type in a straightforward way (you can think of the "N" in "PairN" as standing
for "naive"):
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">newtype</span> <span style="color: #228b22;">PairN</span> a b <span style="color: #8b6914;">=</span> <span style="color: #228b22;">PairN</span> { pairN <span style="color: #8b6914;">::</span> (a, b)}
  <span style="color: #a020f0;">deriving</span> <span style="color: #228b22;">Show</span>
</pre>
</div>

<p>
Then we try to claim <code>PairN</code> is a <code>Functor</code> by implementing <code>fmap</code>.  We only supply one argument
to <code>PairN</code> below because that's the way <i>Learn You a Haskell</i> does it in Chapter 12:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #a020f0;">instance</span> <span style="color: #228b22;">Functor</span> (<span style="color: #228b22;">PairN</span> c) <span style="color: #a020f0;">where</span>
  fmap f (<span style="color: #228b22;">PairN</span> (x,y)) <span style="color: #8b6914;">=</span> <span style="color: #228b22;">PairN</span> (f x, y)
</pre>
</div>

<p>
Unfortunately, when we try to compile, we get a faceful of errors.
</p>

<p>
Obviously, we did it wrong, because we ignored the way the book does it, but let's entertain
ourselves by puzzling out what these errors mean rather than hurrying past them with our eyes
averted.
</p>

<p>
As usual, we start with only the last error, since that's the proximate cause of the cascade.
</p>
</div>
</div>

<div id="outline-container-org7cb7862" class="outline-2">
<h2 id="org7cb7862"><span class="section-number-2">3</span> Errors</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
/Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:35: error:
    • Couldn't match expected type ‘a’ with actual type ‘c’
      ‘c’ is a rigid type variable bound by
        the instance declaration
        at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:43:10-26
</pre>

<p>
So, this is the part of the instance declaration where we say <code>PairN c</code> is a functor.
</p>

<p>
What's going on here is we're declaring the <i>type</i> <code>(PairN c)</code> to be an <i>instance</i> of the
<i>typeclass</i> <code>Functor</code>.
</p>

<p>
So, the question is: How is <code>(PairN c)</code> a type?  Isn't it just <code>PairN</code> that's the type?
</p>

<p>
Well, yes, sort of.  The actual type is <code>PairN a b</code>.  If you (comment out the lines that generate
the errors and) fire up <code>ghci</code>, you can see it:
</p>

<pre class="example">
λ *Main&gt; :k Int
Int :: *

λ *Main&gt; :k PairN _ _
PairN _ _ :: *
</pre>

<p>
So, what was that?  We asked <code>ghci</code> to display the <i>kinds</i> of some types.  <code>Int</code> is a type (plain
old integers), and so is <code>PairN a b</code>, in the sense of "type" that you're probably used to (where a
<code>PairN a b</code> is a thing composed of two other things, the first of which is of some type <i>a</i> and
the second of which is of some type <i>b</i>).  These two kinds are <i>monomorphic</i> or <i>nullary type
constructors</i>, meaning (sort of) they construct types.  Since they don't take any "arguments",
they only construct one type (kind?) of type each (one constructs integer types and the other
constructs pair types (presumably)).
</p>

<p>
So, what is the kind of <code>PairN</code> by itself?
</p>

<pre class="example">
λ *Main&gt; :k PairN
PairN :: * -&gt; * -&gt; *
</pre>

<p>
It's kind of a function that takes two types (the <code>*</code> things) and returns a third type.  And, like
all functions in Haskell, it can be curried.
</p>

<p>
So, now we know two things:
</p>

<ol class="org-ol">
<li><code>PairN c</code> is a function that returns another function mapping one type to another; and</li>

<li>We are claiming that <code>PairN c</code> is a <code>Functor</code> (like we did for <code>MMaybe</code>, above).  This is
reasonable, because <code>(PairN c)</code> is like <code>MMaybe</code> in that it takes a single type parameter and
returns a new type.  <code>Maybe Int</code> is a certain type, and so is <code>(PairN c) Int</code>.</li>
</ol>

<p>
The error continues:
</p>

<pre class="example">
‘a’ is a rigid type variable bound by
  the type signature for:
    fmap :: forall a b. (a -&gt; b) -&gt; PairN c a -&gt; PairN c b
  at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:3-6
</pre>

<p>
So, from the definition of <code>Functor</code> at the very top, <code>fmap</code> takes a simple function (<code>(a -&gt; b)</code>),
and a <i>functor</i> type <i>f</i> that looks like <code>f a</code> (like <code>Maybe a</code>, but in our case it's <code>PairN c a</code>),
and returns a thing of a different type (<code>Maybe b</code> or <code>PairN c b</code>, where we're remembering that
<code>a</code>, <code>b</code>, and <code>c</code> are all type variables, not data variables).
</p>

<p>
So, to be clear: we're claiming there's a function from things of type <i>a</i> to things of type <i>b</i>,
but we handed that function things of type <i>c</i> and <code>ghc</code> is saying, "Hey, wait a minute, you told
me one type and gave me another type".  There's nothing that says types <i>c</i> and <i>a</i> are the same.
</p>

<p>
<code>ghc</code> helps us figure all that out because it very helpfully provides a list of the symbol
bindings it had in its head when it encountered this problem:
</p>

<pre class="example">
    • In the first argument of ‘f’, namely ‘x’
      In the expression: f x
      In the first argument of ‘PairN’, namely ‘(f x, y)’
    • Relevant bindings include
        y :: a
          (bound at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:20)
        x :: c
          (bound at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:18)
        f :: a -&gt; b
          (bound at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:8)
        fmap :: (a -&gt; b) -&gt; PairN c a -&gt; PairN c b
          (bound at /Users/john/Development/Haskell/NewTypeFun/newTypeFun.hs:44:3)
   |
44 |   fmap f (PairN (x,y)) = PairN (f x, y)
   |                                   ^
</pre>

<p>
So, we said <code>PairN a b</code> values are pairs where the first element, <i>x</i>, is
something of type <i>a</i>, and the second element, <i>y</i>, is something of type <i>b</i>.
</p>

<p>
Then, we tried to use a function, <i>f</i>, but we handed it things of type <i>c</i> without saying that <i>c</i>
and <i>a</i> are the same (and really, we can't say that because they're both sort of free-floating
types &#x2013; they could each be anything).  Maybe if there was a lambda operator for types we could
solve this problem, somehow.
</p>

<pre class="example">
instance Functor (\c -&gt; PairN _ c) where...

</pre>

<p>
But what goes in that <code>_</code>?
</p>

<pre class="example">
instance Functor ( (PairN) c) where...

</pre>

<p>
Here I'm trying to turn <code>PairN</code> into an infix binary operator where the first type parameter is
the "floating" argument (attempting to curry the 2nd parameter, I guess), but what if we had a
type constructor that took 3 or more arguments?  Eww.
</p>

<p>
So, anyway, that's why you have to reverse the <i>a</i> and <i>b</i> in the definition of <code>Pair</code>.
Craziness, eh?
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2018-10-17 Wed 15:18</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.1 (<a href="http://orgmode.org">Org</a> mode 9.1.2)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>